%{
    /* Include the shared header file for the Node structure and related functions. */
    #include "node.h"
    
    /* Include the parser header generated by Bison for token definitions and external interfaces. */
    #include "parser.tab.h"

    /* Standard libraries for memory allocation and string operations. */
    #include <stdlib.h>
    #include <string.h>

    /* External declarations for error reporting and yytext string. */
    extern char *yytext; 
    extern void yyerror(const char* s); 
%}

    /* Enable line number tracking for error reporting in the parser. */
%option yylineno

    /* Suppress default input and unput functions as they are not needed. */
%option nounput
%option noinput

%%

    /* Match integers (e.g., 123) and store the value as a string for the intermediate representation (IR). */
[0-9]+ {
    yylval.str = strdup(yytext); /* Convert the matched text into a dynamically allocated string. */
    return INTEGER;
}

    /* Match end-of-line characters, supporting both Unix (`\n`) and Windows (`\r\n`) line endings. */
\r?\n { 
    return END_OF_LINE; 
}

    /* Match spaces and tabs and ignore them in the input. */
[ \t]+ { 
    /* Ignore whitespace */ 
}

    /* Match strings enclosed in custom delimiters (e.g., 👉text👈). */
👉([^👈]+)👈 {
    char *str = strdup(yytext); /* Duplicate the matched text. */

    /* Adjust the pointer to skip the emoji delimiters and null-terminate the string correctly. */
    str += 4; 
    str[strlen(str) - 4] = '\0'; 

    yylval.str = str; /* Store the processed string in the parser's value. */
    return STRING;
}

    /* Match parentheses for grouping expressions. */
"(" { return PARENTHESIS_OPEN; }
")" { return PARENTHESIS_CLOSE; }

    /* Match custom comment syntax (e.g., 👅some comment) and ignore the line. */
👅.* { 
    /* Ignore comments */ 
}

    /* Match program structure emojis for start and end markers. */
👍️ { return PROGRAM_BEGIN; }
👎️ { return PROGRAM_END; }

    /* Match data type keywords. */
💯 { return INTEGER_TYPE; }
🔤 { return STRING_TYPE; }
🔢 { return INT_ARRAY_TYPE; }
⁉️ { return BOOL_TYPE; }

    /* Match boolean literals. */
✅ { return TRUE; }
❌ { return FALSE; }

    /* Match variable and array declaration. */
🪣 { return VARIABLE_DECLARATION; }
🚬 { return ARRAY_DECLARATION_DIVIDER; }

    /* Match array access syntax. */
🔎 { return ACCESS_ARRAY; }

    /* Match arithmetic operators. */
➕ { return INTEGER_ADDITION; }
➖ { return INTEGER_SUBTRACTION; }
✖ { return INTEGER_MULTIPLICATION; }
➗ { return INTEGER_DIVISION; }
♻ { return INTEGER_MODULUS; }

    /* Match assignment operator. */
🟰 { return ASSIGN; }

    /* Match comparison operators. */
🔼 { return GREATER_THAN; }
🔽 { return LESS_THAN; }
⏫ { return GREATER_THAN_EQUAL; }
⏬ { return LESS_THAN_EQUAL; }
🔁 { return EQUAL; }
🔀 { return NOT_EQUAL; }

    /* Match logical operators. */
❗ { return NEGATION; }
🅰 { return AND; }
🅾 { return OR; }

    /* Match control flow keywords for conditional and loop structures. */
🤔 { return IF_START; }
😬 { return IF_END; }
😒 { return ELSE; }
🫸 { return CONDITION_BEGIN; }
🫷 { return CONDITION_END; }
🐣 { return FOR_BEGIN; }
🐥 { return FOR_END; }
🚭 { return FOR_CONDITION_SEPARATOR; }
🐳 { return WHILE_BEGIN; }
🐋 { return WHILE_END; }

    /* Match print and input statements. */
💅 { return PRINT_STATEMENT; }
✍ { return INPUT_STATEMENT; }

    /* Match identifiers (e.g., variable or function names). */
[a-zA-Z_][a-zA-Z0-9_]* {
    yylval.str = strdup(yytext); /* Copy the matched identifier name. */
    return IDENTIFIER;          /* Return the IDENTIFIER token. */
}

    /* Match any unrecognized character and raise a parsing error. */
. {
    yyerror("Invalid character encountered");
    return 0;
}

%%

    /* Handle the end of input stream. */
int yywrap() {
    return 1;
}
