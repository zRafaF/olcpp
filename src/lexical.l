%{
    /* Include the shared header file for the Node structure and related functions. */
    #include "node.h"
    
    /* Include the parser header generated by Bison for token definitions and external interfaces. */
    #include "parser.tab.h"

    /* Standard libraries for memory allocation and string operations. */
    #include <stdlib.h>
    #include <string.h>

    /* External declarations for error reporting and yytext string. */
    extern char *yytext; 
    extern void yyerror(const char* s); 
%}

    /* Enable line number tracking for error reporting in the parser. */
%option yylineno

    /* Suppress default input and unput functions as they are not needed. */
%option nounput
%option noinput

%%

    /* Match integers (e.g., 123) and store the value as a string for the intermediate representation (IR). */
[0-9]+ {
    yylval.str = strdup(yytext); /* Convert the matched text into a dynamically allocated string. */
    return INTEGER;
}

    /* Match end-of-line characters, supporting both Unix (`\n`) and Windows (`\r\n`) line endings. */
\r?\n { 
    return END_OF_LINE; 
}

    /* Match spaces and tabs and ignore them in the input. */
[ \t]+ { 
    /* Ignore whitespace */ 
}

    /* Match strings enclosed in custom delimiters (e.g., ğŸ‘‰textğŸ‘ˆ). */
ğŸ‘‰([^ğŸ‘ˆ]+)ğŸ‘ˆ {
    char *str = strdup(yytext); /* Duplicate the matched text. */

    /* Adjust the pointer to skip the emoji delimiters and null-terminate the string correctly. */
    str += 4; 
    str[strlen(str) - 4] = '\0'; 

    yylval.str = str; /* Store the processed string in the parser's value. */
    return STRING;
}

    /* Match parentheses for grouping expressions. */
"(" { return PARENTHESIS_OPEN; }
")" { return PARENTHESIS_CLOSE; }

    /* Match custom comment syntax (e.g., ğŸ‘…some comment) and ignore the line. */
ğŸ‘….* { 
    /* Ignore comments */ 
}

    /* Match program structure emojis for start and end markers. */
ğŸ‘ï¸ { return PROGRAM_BEGIN; }
ğŸ‘ï¸ { return PROGRAM_END; }

    /* Match data type keywords. */
ğŸ’¯ { return INTEGER_TYPE; }
ğŸ”¤ { return STRING_TYPE; }
ğŸ”¢ { return INT_ARRAY_TYPE; }
â‰ï¸ { return BOOL_TYPE; }

    /* Match boolean literals. */
âœ… { return TRUE; }
âŒ { return FALSE; }

    /* Match variable and array declaration. */
ğŸª£ { return VARIABLE_DECLARATION; }
ğŸš¬ { return ARRAY_DECLARATION_DIVIDER; }

    /* Match array access syntax. */
ğŸ” { return ACCESS_ARRAY; }

    /* Match arithmetic operators. */
â• { return INTEGER_ADDITION; }
â– { return INTEGER_SUBTRACTION; }
âœ– { return INTEGER_MULTIPLICATION; }
â— { return INTEGER_DIVISION; }
â™» { return INTEGER_MODULUS; }

    /* Match assignment operator. */
ğŸŸ° { return ASSIGN; }

    /* Match comparison operators. */
ğŸ”¼ { return GREATER_THAN; }
ğŸ”½ { return LESS_THAN; }
â« { return GREATER_THAN_EQUAL; }
â¬ { return LESS_THAN_EQUAL; }
ğŸ” { return EQUAL; }
ğŸ”€ { return NOT_EQUAL; }

    /* Match logical operators. */
â— { return NEGATION; }
ğŸ…° { return AND; }
ğŸ…¾ { return OR; }

    /* Match control flow keywords for conditional and loop structures. */
ğŸ¤” { return IF_START; }
ğŸ˜¬ { return IF_END; }
ğŸ˜’ { return ELSE; }
ğŸ«¸ { return CONDITION_BEGIN; }
ğŸ«· { return CONDITION_END; }
ğŸ£ { return FOR_BEGIN; }
ğŸ¥ { return FOR_END; }
ğŸš­ { return FOR_CONDITION_SEPARATOR; }
ğŸ³ { return WHILE_BEGIN; }
ğŸ‹ { return WHILE_END; }

    /* Match print and input statements. */
ğŸ’… { return PRINT_STATEMENT; }
âœ { return INPUT_STATEMENT; }

    /* Match identifiers (e.g., variable or function names). */
[a-zA-Z_][a-zA-Z0-9_]* {
    yylval.str = strdup(yytext); /* Copy the matched identifier name. */
    return IDENTIFIER;          /* Return the IDENTIFIER token. */
}

    /* Match any unrecognized character and raise a parsing error. */
. {
    yyerror("Invalid character encountered");
    return 0;
}

%%

    /* Handle the end of input stream. */
int yywrap() {
    return 1;
}
