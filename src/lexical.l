%{
    #include "parser.tab.h"
    #include <stdlib.h>
    #include <string.h>

    extern char *yytext; // Declare yytext
    extern void yyerror(const char* s);  // Declare yyerror

%}

%%

[0-9]+ {
    yylval.num = atoi(yytext);
    return INTEGER;
}

\n { return END_OF_LINE; }

[ \t]+ { /* Ignore whitespace */ }

. {
    yyerror("Invalid character encountered");
    return 0;
}

ğŸ‘ï¸ { return PROGRAM_BEGIN; }
ğŸ‘ï¸ { return PROGRAM_END; }
ğŸ’¯ { return INTEGER_TYPE; }
ğŸ”¤ { return STRING_TYPE; }
ğŸ”¢ { return INT_ARRAY_TYPE; }
â‰ï¸ { return BOOL_TYPE; }
âœ… { return BOOL_TRUE; }
âŒ { return BOOL_FALSE; }

ğŸ‘‰[^"\n]*ğŸ‘ˆ {
    char *temp = strdup(yytext + 2);  // Remove "ğŸ‘‰"
    temp[strlen(temp) - 2] = '\0';    // Remove "ğŸ‘ˆ"
    yylval.str = temp;
    return STRING;
}

ğŸª£ { return VARIABLE_DECLARATION; }
ğŸš¬ { return ARRAY_DECLARATION_DIVIDER; }
â• { return INTEGER_ADDITION; }
â– { return INTEGER_SUBTRACTION; }
âœ– { return INTEGER_MULTIPLICATION; }
â— { return INTEGER_DIVISION; }
â™» { return INTEGER_MODULUS; }
ğŸŸ° { return ASSIGN; }
ğŸ”¼ { return GREATER_THAN; }
ğŸ”½ { return LESS_THAN; }
â« { return GREATER_THAN_EQUAL; }
â¬ { return LESS_THAN_EQUAL; }
ğŸ” { return EQUAL; }
ğŸ”€ { return NOT_EQUAL; }
â— { return NEGATION; }
ğŸ…° { return AND; }
ğŸ…¾ { return OR; }
ğŸ¤” { return IF_START; }
ğŸ˜¬ { return IF_END; }
ğŸ˜’ { return ELSE; }
ğŸ«¸ { return CONDITION_BEGIN; }
ğŸ«· { return CONDITION_END; }
ğŸ£ { return FOR_BEGIN; }
ğŸ¥ { return FOR_END; }
ğŸš­ { return FOR_CONDITION_SEPARATOR; }
ğŸ³ { return WHILE_BEGIN; }
ğŸ‹ { return WHILE_END; }
ğŸ’… { return PRINT; }
âœ { return INPUT; }

    /* Ignore comments*/
ğŸ‘….* { /* Do nothing */ }

%%

int yywrap() {
    return 1;
}
